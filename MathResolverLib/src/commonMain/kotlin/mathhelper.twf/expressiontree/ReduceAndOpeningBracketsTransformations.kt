package mathhelper.twf.expressiontree

import mathhelper.twf.api.normalizeExpressionToUsualForm
import mathhelper.twf.config.CompiledConfiguration



fun generalOpeningBracketsSubstitutions(originalExpression: ExpressionNode, transformationNode: ExpressionNode?, transformationNodeParent: ExpressionNode?, transformationNodeIndex: Int,
                                         compiledConfiguration: CompiledConfiguration,
                                         expressionToTransform: ExpressionNode = originalExpression, notSelectedSubtreeTopArguments: ExpressionNode? = null, notSelectedSubtreeTopOriginalTree: ExpressionNode? = null, fullTransformationNode: ExpressionNode? = transformationNode,
                                        simplifyNotSelectedTopArguments: Boolean = false): List<SubstitutionApplication> {
    val result = mutableListOf<SubstitutionApplication>()
    if (compiledConfiguration.expressionTreeAutogeneratedTransformationRuleIdentifiers.containsKey("OpeningBrackets")) {
        val subst = compiledConfiguration.expressionTreeAutogeneratedTransformationRuleIdentifiers["OpeningBrackets"]!!
        val dotOperation: String = transformationNode!!.value
        val plusOperation: String = plusOperationByDot(dotOperation)
        if (plusOperation.isNotBlank()) {
            if (dotOperation != "/" &&
                    transformationNode!!.children.last().value == plusOperation &&
                    transformationNode!!.children.last().children.size > 1) {
                // all from fist X all from last transformation
                val sumNode = compiledConfiguration.createExpressionFunctionNode(plusOperation, -1)
                val lChildren = if (transformationNode!!.children.first().value == plusOperation) {
                    transformationNode!!.children.first().children
                } else {
                    listOf(transformationNode!!.children.first())
                }
                val rChildren = if (transformationNode!!.children.last().value == plusOperation) {
                    transformationNode!!.children.last().children
                } else {
                    listOf(transformationNode!!.children.last())
                }
                addSumOpeningBracketsResult(originalExpression, transformationNode, transformationNodeParent, transformationNodeIndex, expressionToTransform,
                        notSelectedSubtreeTopArguments, notSelectedSubtreeTopOriginalTree, fullTransformationNode,
                        lChildren, rChildren, compiledConfiguration, sumNode, simplifyNotSelectedTopArguments, result)
            }

            if (transformationNode!!.children.first().value == plusOperation &&
                    transformationNode!!.children.first().children.size > 1) {
                // all from fist X last transformation
                val sumNode = compiledConfiguration.createExpressionFunctionNode(plusOperation, -1)
                val lChildren = if (transformationNode!!.children.first().value == plusOperation) {
                    transformationNode!!.children.first().children
                } else {
                    listOf(transformationNode!!.children.first())
                }
                val rChildren = listOf(transformationNode!!.children.last())
                addSumOpeningBracketsResult(originalExpression, transformationNode, transformationNodeParent, transformationNodeIndex, expressionToTransform,
                        notSelectedSubtreeTopArguments, notSelectedSubtreeTopOriginalTree, fullTransformationNode,
                        lChildren, rChildren, compiledConfiguration, sumNode, simplifyNotSelectedTopArguments, result)
            }
        }
    }
    return result
}

fun plusOperationByDot(dotOperation: String): String = when (dotOperation) {
    "*","/" -> "+"
    "and" -> "or"
    "or" -> "and"
    else -> ""
}

fun dotOperationByPlus(plusOperation: String) = when (plusOperation) {
    "+" -> "*"
    "and" -> "or"
    "or" -> "and"
    else -> ""
}

private fun addSumOpeningBracketsResult(originalExpression: ExpressionNode, transformationNode: ExpressionNode?, transformationNodeParent: ExpressionNode?, transformationNodeIndex: Int, expressionToTransform: ExpressionNode,
                                        notSelectedSubtreeTopArguments: ExpressionNode?, notSelectedSubtreeTopOriginalTree: ExpressionNode?, fullTransformationNode: ExpressionNode?,
                                        lChildren: List<ExpressionNode>, rChildren: List<ExpressionNode>, compiledConfiguration: CompiledConfiguration, sumNode: ExpressionNode, simplifyNotSelectedTopArguments: Boolean, result: MutableList<SubstitutionApplication>) {
    if (compiledConfiguration.expressionTreeAutogeneratedTransformationRuleIdentifiers.containsKey("OpeningBrackets")) {
        val subst = compiledConfiguration.expressionTreeAutogeneratedTransformationRuleIdentifiers["OpeningBrackets"]!!
        for (lChild in lChildren) {
            for (rChild in rChildren) {
                val productionNode = compiledConfiguration.createExpressionFunctionNode(transformationNode!!.value, -1)
                var needMinus = false
                val lMul = if (lChild.value == "-") {
                    needMinus = needMinus xor true
                    lChild.children.first()
                } else lChild
                val rMul = if (rChild.value == "-") {
                    needMinus = needMinus xor true
                    rChild.children.first()
                } else rChild
                productionNode.addChild(lMul.clone())
                productionNode.addChild(rMul.clone())
                if (needMinus) {
                    val minusNode = compiledConfiguration.createExpressionFunctionNode("-", -1)
                    minusNode.addChild(productionNode)
                    sumNode.addChild(minusNode)
                } else {
                    sumNode.addChild(productionNode)
                }
            }
        }
        addApplicationToResults(originalExpression, transformationNode, transformationNodeParent, transformationNodeIndex, expressionToTransform,
                notSelectedSubtreeTopArguments, notSelectedSubtreeTopOriginalTree, fullTransformationNode,
                true, compiledConfiguration, simplifyNotSelectedTopArguments,
                sumNode,
                result,
                ExpressionSubstitution(addRootNodeToExpression(transformationNode!!.clone()), addRootNodeToExpression(sumNode), code = subst.code, nameEn = subst.nameEn, nameRu = subst.nameRu, priority = subst.priority)
                , "OpeningBrackets", subst.priority ?: 20)
    }
}

private fun addApplicationToResults(originalExpression: ExpressionNode, transformationNode: ExpressionNode?, transformationNodeParent: ExpressionNode?, transformationNodeIndex: Int, expressionToTransform: ExpressionNode,
                                    notSelectedSubtreeTopArguments: ExpressionNode?, notSelectedSubtreeTopOriginalTree: ExpressionNode?, fullTransformationNode: ExpressionNode?,
//default fastest line is to run with 'simplifyNotSelectedTopArguments' = 'true' && 'onSameBracketLevel' = 'false'
        withReadyApplicationResult: Boolean,
        compiledConfiguration: CompiledConfiguration,
        simplifyNotSelectedTopArguments: Boolean,
        applicationToSelectedPartResult: ExpressionNode,
        result: MutableList<SubstitutionApplication>,
        transformation: ExpressionSubstitution,
        substitutionType: String,
        priority: Int,
        onSameBracketLevel: Boolean = false) {
    val originalExpression = originalExpression.clone()
    if (withReadyApplicationResult) {
        if (notSelectedSubtreeTopArguments != null) {
            val applicationResultNode = if (onSameBracketLevel && notSelectedSubtreeTopArguments!!.value == applicationToSelectedPartResult.value) {
                applicationToSelectedPartResult.clone().apply {
                    if (simplifyNotSelectedTopArguments) {
                        for (i in 1..notSelectedSubtreeTopArguments!!.children.lastIndex) {
                            addChild(notSelectedSubtreeTopArguments!!.children[i])
                        }
                    } else {
                        for (child in notSelectedSubtreeTopOriginalTree!!.children) {
                            addChild(child)
                        }
                    }
                }
            } else if (simplifyNotSelectedTopArguments) {
                notSelectedSubtreeTopArguments!!.apply { setChildOnPosition(applicationToSelectedPartResult, 0) }
            } else {
                val commutativeOperationNode = notSelectedSubtreeTopArguments!!.copy()
                commutativeOperationNode.addChild(applicationToSelectedPartResult)
                for (child in notSelectedSubtreeTopOriginalTree!!.children) {
                    commutativeOperationNode.addChild(child)
                }
                commutativeOperationNode
            }
            if (transformationNodeParent != null) {
                transformationNodeParent!!.setChildOnPosition(applicationResultNode, transformationNodeIndex)
            }
        } else {
            if (transformationNodeParent != null) {
                transformationNodeParent!!.setChildOnPosition(applicationToSelectedPartResult, transformationNodeIndex)
            }
        }
    }
    result.add(SubstitutionApplication(
            transformation,
            originalExpression,
            transformationNode!!,
            if (withReadyApplicationResult) {
                expressionToTransform.clone().apply {
                    normalizeExpressionToUsualForm(this, compiledConfiguration)
                } //because this code performs lots times for lots of substitutions
            } else {
                ExpressionNode(NodeType.EMPTY, "To get application result use argument 'withReadyApplicationResult' = 'true'")
            },
            applicationToSelectedPartResult,
            substitutionType, priority
    ))
    transformationNodeParent!!.setChildOnPosition(fullTransformationNode!!, transformationNodeIndex)
}

fun ExpressionNode.computeResultsOfOpeningBracketsSubstitutions(compiledConfiguration: CompiledConfiguration, originalExpression: ExpressionNode = this): List<ExpressionNode> {
    val result = mutableListOf<ExpressionNode>()
    for (i in 0..children.lastIndex) {
        if ("${children[i].value}_${children[i].children.size}" !in compiledConfiguration.definedFunctionNameNumberOfArgsSet && children[i].value + "_-1" !in compiledConfiguration.definedFunctionNameNumberOfArgsSet) {
            result.addAll(generalOpeningBracketsSubstitutions(originalExpression, children[i], this, i, compiledConfiguration).map { it.resultExpression })
        }
        result.addAll(children[i].computeResultsOfOpeningBracketsSubstitutions(compiledConfiguration, originalExpression))
    }
    return result
}